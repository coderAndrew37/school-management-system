"use server";

import { createServerClient } from "@/lib/supabase/client";
import { AdmissionActionResult, admissionSchema } from "../schemas/admission";

export async function admitStudentAction(
  formData: FormData,
): Promise<AdmissionActionResult> {
  // 1. Extract raw values from FormData
  const raw = {
    studentName: formData.get("studentName"),
    dateOfBirth: formData.get("dateOfBirth"),
    gender: formData.get("gender"),
    currentGrade: formData.get("currentGrade"),
    parentPhone: formData.get("parentPhone"),
  };

  // 2. Validate with Zod
  const parsed = admissionSchema.safeParse(raw);

  if (!parsed.success) {
    const firstError = parsed.error.issues[0]?.message ?? "Validation failed.";
    return { success: false, message: firstError };
  }

  const { studentName, dateOfBirth, gender, currentGrade, parentPhone } =
    parsed.data;

  const supabase = createServerClient();

  try {
    // 3. Upsert parent by phone number (create if new, return existing if found)
    const { data: existingParents, error: parentFetchError } = await supabase
      .from("parents")
      .select("id")
      .eq("phone_number", parentPhone)
      .limit(1);

    if (parentFetchError) {
      console.error("Parent fetch error:", parentFetchError);
      return {
        success: false,
        message: "Failed to look up parent record. Please try again.",
      };
    }

    let parentId: string;

    if (existingParents && existingParents.length > 0 && existingParents[0]) {
      // Parent already exists
      parentId = existingParents[0].id;
    } else {
      // Create a new parent record with phone as the primary identifier
      // full_name and email are NOT NULL in schema, so we use placeholders
      // In a real flow you'd collect these â€” adjust as needed
      const { data: newParent, error: parentInsertError } = await supabase
        .from("parents")
        .insert({
          full_name: "To be updated",
          email: `${parentPhone.replace(/\D/g, "")}@placeholder.local`,
          phone_number: parentPhone,
        })
        .select("id")
        .single();

      if (parentInsertError || !newParent) {
        console.error("Parent insert error:", parentInsertError);
        return {
          success: false,
          message:
            "Failed to register parent. The phone number may already be linked to an account.",
        };
      }

      parentId = newParent.id;
    }

    // 4. Insert student (readable_id is auto-generated by DB trigger)
    const { data: student, error: studentInsertError } = await supabase
      .from("students")
      .insert({
        full_name: studentName,
        date_of_birth: dateOfBirth,
        gender: gender,
        current_grade: currentGrade,
        parent_id: parentId,
      })
      .select("id, readable_id")
      .single();

    if (studentInsertError || !student) {
      console.error("Student insert error:", studentInsertError);
      return {
        success: false,
        message: "Failed to admit student. Please try again.",
      };
    }

    return {
      success: true,
      message: `Student admitted successfully! ID: ${student.readable_id ?? student.id}`,
      studentId: student.id,
      readableId: student.readable_id ?? undefined,
    };
  } catch (err) {
    console.error("Unexpected error in admitStudentAction:", err);
    return {
      success: false,
      message: "An unexpected error occurred. Please try again.",
    };
  }
}
